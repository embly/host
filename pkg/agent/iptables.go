package agent

import (
	"bufio"
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"strings"

	"github.com/embly/host/pkg/exec"
	"github.com/embly/host/pkg/iptables"
)

type IPTables interface {
	CreateChains() (err error)
	DeleteChains() (err error)
	AddProxyRule(pr ProxyRule) (err error)
	AddProxyRuleToPrerouting(pr ProxyRule) (err error)
	CleanUpPreroutingRules() (err error)
	RuleExists(pr ProxyRule) (exists bool, err error)
	DeleteProxyRule(pr ProxyRule) (err error)
	GetRules(chain string) (stats []iptables.Stat, err error)
}

type defaultIPTables struct {
	ipt *iptables.IPTables
}

func NewIPTables(execInterface exec.Interface) func() (IPTables, error) {
	return func() (IPTables, error) {
		var err error
		ipt := &defaultIPTables{}
		ipt.ipt, err = iptables.NewWithProtocol(iptables.ProtocolIPv4, execInterface)
		return ipt, err
	}
}

var (
	emblyPreroutingChain = "EMBLY_PREROUTING"
	prerouting           = "PREROUTING"
	commentText          = "generated by embly"
)

func (ipt *defaultIPTables) CreateChains() (err error) {
	err = ipt.ipt.NewChain("nat", emblyPreroutingChain)
	if isChainExistsErr(err) {
		return nil
	}
	var exists bool
	if exists, err = ipt.ipt.Exists("nat", "PREROUTING", "-j", emblyPreroutingChain); err != nil {
		return
	}
	if !exists {
		if err = ipt.ipt.Append("nat", "PREROUTING", "-j", emblyPreroutingChain); err != nil {
			return
		}
	}
	return
}

func (ipt *defaultIPTables) DeleteChains() (err error) {
	if err = ipt.ipt.ClearChain("nat", emblyPreroutingChain); err != nil {
		return
	}
	if err = ipt.ipt.Delete("nat", "PREROUTING", "-j", emblyPreroutingChain); err != nil {
		return
	}

	return ipt.ipt.DeleteChain("nat", emblyPreroutingChain)
}

type ProxyRule struct {
	proxyIP       string
	containerIP   string
	proxyPort     int
	containerPort int
}

func (pr ProxyRule) preroutingArgs() []string {
	// sudo iptables -t nat -A PREROUTING -p tcp -d 192.168.86.30 --dport 80 -j DNAT --to-destination 192.168.86.30:8084
	return []string{
		"--protocol", "tcp",
		"--destination", pr.proxyIP,
		"--source", pr.containerIP,
		"--dport", fmt.Sprint(pr.containerPort),
		"--jump", "DNAT",
		"--to-destination", fmt.Sprintf("%s:%d", pr.proxyIP, pr.proxyPort),
		"--match", "comment",
		"--comment", commentText,
	}
}

func (ipt *defaultIPTables) natAppendIfNoExist(chain string, args []string) (err error) {
	return ipt.ipt.AppendUnique("nat", chain, args...)
}

func (ipt *defaultIPTables) AddProxyRule(pr ProxyRule) (err error) {
	return ipt.natAppendIfNoExist(emblyPreroutingChain, pr.preroutingArgs())
}

func (ipt *defaultIPTables) AddProxyRuleToPrerouting(pr ProxyRule) (err error) {
	return ipt.ipt.Append("nat", prerouting, pr.preroutingArgs()...)
}

func (ipt *defaultIPTables) CleanUpPreroutingRules() (err error) {
	cmd := ipt.ipt.Exec.Command("iptables-save")
	rules, err := cmd.CombinedOutput()
	if err != nil {
		return
	}
	lineReader := bufio.NewReader(bytes.NewBuffer(rules))
	var args []string
	for {
		var line []byte
		line, _, err = lineReader.ReadLine()
		if err == io.EOF {
			break
		}
		if err != nil {
			return
		}
		if bytes.Contains(line, []byte(commentText)) && bytes.Contains(line, []byte("-A PREROUTING")) {
			args = append(args, string(bytes.TrimPrefix(line, []byte("-A PREROUTING "))))
		}
	}
	for _, arg := range args {
		r := csv.NewReader(strings.NewReader(arg))
		r.Comma = ' ' // space
		var fields []string
		fields, err = r.Read()
		if err != nil {
			return
		}
		if err = ipt.ipt.Delete("nat", prerouting, fields...); err != nil {
			return
		}
	}
	return nil
}

func (ipt *defaultIPTables) RuleExists(pr ProxyRule) (exists bool, err error) {
	return ipt.ipt.Exists("nat", emblyPreroutingChain, pr.preroutingArgs()...)
}

func (ipt *defaultIPTables) DeleteProxyRule(pr ProxyRule) (err error) {
	return ipt.ipt.Delete("nat", emblyPreroutingChain, pr.preroutingArgs()...)
}

func (ipt *defaultIPTables) GetRules(chain string) (stats []iptables.Stat, err error) {
	return ipt.ipt.StructuredStats("nat", chain)
}

func isChainExistsErr(err error) bool {
	if err == nil {
		return false
	}
	return strings.Contains(err.Error(), "Chain already exists")
}
